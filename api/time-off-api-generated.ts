/* tslint:disable */
/* eslint-disable */
/*
Bob API

Access your employees data with the Bob API

The version of the OpenAPI document: 1.0.0


NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
import { fromBuffer } from "file-type/browser"
const FormData = require("form-data")
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { AdjustmentRequest } from '../models';
// @ts-ignore
import { BalanceResult } from '../models';
// @ts-ignore
import { OutTodays } from '../models';
// @ts-ignore
import { Policy } from '../models';
// @ts-ignore
import { PolicyNames } from '../models';
// @ts-ignore
import { PolicyType } from '../models';
// @ts-ignore
import { PolicyTypes } from '../models';
// @ts-ignore
import { ReasonCodes } from '../models';
// @ts-ignore
import { ReasonCodesNames } from '../models';
// @ts-ignore
import { Requests } from '../models';
// @ts-ignore
import { SubmitTimeoffRequest } from '../models';
// @ts-ignore
import { SubmitTimeoffRequestDiffHours } from '../models';
// @ts-ignore
import { SubmitTimeoffRequestDiffHoursDurationsInner } from '../models';
// @ts-ignore
import { TimeoffChanges } from '../models';
// @ts-ignore
import { TimeoffRequest } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * TimeOffApi - axios parameter creator
 * @export
 */
export const TimeOffApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a list of reason codes for a given policy type.<br /><b>Supported user types:</b> Service.
         * @summary Add a list of reason codes for a given policy type.
         * @param {string} policyType Policy Type name
         * @param {ReasonCodesNames} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addReasonCodes: async (policyType: string, body: ReasonCodesNames, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyType' is not null or undefined
            assertParamExists('addReasonCodes', 'policyType', policyType)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('addReasonCodes', 'body', body)
            const localVarPath = `/timeoff/policy-types/{policyType}/reason-codes`
                .replace(`{${"policyType"}}`, encodeURIComponent(String(policyType !== undefined ? policyType : `-policyType-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: body,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/timeoff/policy-types/{policyType}/reason-codes',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancels an existing time off request.<br />
         * @summary Cancel an existing timeoff request
         * @param {string} id Employee ID.
         * @param {number} requestId Request ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelRequest: async (id: string, requestId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cancelRequest', 'id', id)
            // verify required parameter 'requestId' is not null or undefined
            assertParamExists('cancelRequest', 'requestId', requestId)
            const localVarPath = `/timeoff/employees/{id}/requests/{requestId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)))
                .replace(`{${"requestId"}}`, encodeURIComponent(String(requestId !== undefined ? requestId : `-requestId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/timeoff/employees/{id}/requests/{requestId}',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a balance adjustment for a given employee for a given effective date.<br />
         * @summary Create a balance adjustment.
         * @param {string} id Employee ID.
         * @param {AdjustmentRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBalanceAdjustment: async (id: string, body: AdjustmentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createBalanceAdjustment', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createBalanceAdjustment', 'body', body)
            const localVarPath = `/timeoff/employees/{id}/adjustments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: body,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/timeoff/employees/{id}/adjustments',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Supplies detailed info about an existing time off request.<br />
         * @summary Get the details of an existing timeoff request.
         * @param {string} id employee id
         * @param {number} requestId request id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDetailsOfRequest: async (id: string, requestId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDetailsOfRequest', 'id', id)
            // verify required parameter 'requestId' is not null or undefined
            assertParamExists('getDetailsOfRequest', 'requestId', requestId)
            const localVarPath = `/timeoff/employees/{id}/requests/{requestId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)))
                .replace(`{${"requestId"}}`, encodeURIComponent(String(requestId !== undefined ? requestId : `-requestId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/timeoff/employees/{id}/requests/{requestId}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the balance for a given employee, for a given policy type, as of a given date.<br />
         * @summary Get the balance for a given employee
         * @param {string} id Employee ID.
         * @param {string} policyType Policy type name.
         * @param {string | Date} date Point in time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmployeeBalance: async (id: string, policyType: string, date: string | Date, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getEmployeeBalance', 'id', id)
            // verify required parameter 'policyType' is not null or undefined
            assertParamExists('getEmployeeBalance', 'policyType', policyType)
            // verify required parameter 'date' is not null or undefined
            assertParamExists('getEmployeeBalance', 'date', date)
            const localVarPath = `/timeoff/employees/{id}/balance`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)
            if (policyType !== undefined) {
                localVarQueryParameter['policyType'] = policyType;
            }

            if (date !== undefined) {
                localVarQueryParameter['date'] = (date as any instanceof Date) ?
                    (date as any).toISOString().substr(0,10) :
                    date;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/timeoff/employees/{id}/balance',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of time off requests that are pending, approved or canceled since the specified date.<br />
         * @summary Get all new/deleted time off requests since the specified date.
         * @param {string | Date} since Timestamp starting from which to return the changes. Should be in ISO-8601 format, e.g. 2050-04-05T14:30:24.345Z or 2050-04-05T12:30-02:00.
         * @param {boolean} [includePending] Optional parameter. Indicates whether to include pending requests in the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewDeletedRequestsSinceDate: async (since: string | Date, includePending?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'since' is not null or undefined
            assertParamExists('getNewDeletedRequestsSinceDate', 'since', since)
            const localVarPath = `/timeoff/requests/changes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)
            if (since !== undefined) {
                localVarQueryParameter['since'] = (since as any instanceof Date) ?
                    (since as any).toISOString().substr(0,10) :
                    since;
            }

            if (includePending !== undefined) {
                localVarQueryParameter['includePending'] = includePending;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/timeoff/requests/changes',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of people that have a time off request today or on the specified date.<br />
         * @summary Read a list of who\'s out of the office today or on the specified date.
         * @param {string | Date} [today] Date to report out of the office. If not specified, the date at UTC at the time of the request is used.
         * @param {boolean} [includeHourly] Include Hourly Requests
         * @param {boolean} [includePrivate] Show the policy type\&#39;s name instead of the policy\&#39;s custom public name if the user has permission to view it, and the policy\&#39;s custom public name exists.
         * @param {number} [siteId] The employee\&#39;s site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOutOfOffice: async (today?: string | Date, includeHourly?: boolean, includePrivate?: boolean, siteId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/timeoff/outtoday`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)
            if (today !== undefined) {
                localVarQueryParameter['today'] = (today as any instanceof Date) ?
                    (today as any).toISOString().substr(0,10) :
                    today;
            }

            if (includeHourly !== undefined) {
                localVarQueryParameter['includeHourly'] = includeHourly;
            }

            if (includePrivate !== undefined) {
                localVarQueryParameter['includePrivate'] = includePrivate;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['siteId'] = siteId;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/timeoff/outtoday',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details about a given policy type.<br />
         * @summary Get Policy type details
         * @param {string} policyType Policy Type name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicyDetails: async (policyType: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyType' is not null or undefined
            assertParamExists('getPolicyDetails', 'policyType', policyType)
            const localVarPath = `/timeoff/policy-types/{policyType}`
                .replace(`{${"policyType"}}`, encodeURIComponent(String(policyType !== undefined ? policyType : `-policyType-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/timeoff/policy-types/{policyType}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details about a given policy.<br />
         * @summary Get Policy details.
         * @param {string} policyName Policy name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicyDetails_1: async (policyName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyName' is not null or undefined
            assertParamExists('getPolicyDetails_1', 'policyName', policyName)
            const localVarPath = `/timeoff/policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)
            if (policyName !== undefined) {
                localVarQueryParameter['policyName'] = policyName;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/timeoff/policies',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns time off information for a given date range.<br /><b>Supported user types:</b> Service.
         * @summary Read a list of who\'s out of the office.
         * @param {string | Date} from Start period date
         * @param {string | Date} to End period date
         * @param {boolean} [includeHourly] Include Hourly Requests
         * @param {boolean} [includePrivate] Show the policy type\&#39;s name instead of the policy\&#39;s custom public name if the user has permission to view it, and the policy\&#39;s custom public name exists.
         * @param {boolean} [includePending] Include Pending Requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWhosOut: async (from: string | Date, to: string | Date, includeHourly?: boolean, includePrivate?: boolean, includePending?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'from' is not null or undefined
            assertParamExists('getWhosOut', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('getWhosOut', 'to', to)
            const localVarPath = `/timeoff/whosout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)
            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString().substr(0,10) :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString().substr(0,10) :
                    to;
            }

            if (includeHourly !== undefined) {
                localVarQueryParameter['includeHourly'] = includeHourly;
            }

            if (includePrivate !== undefined) {
                localVarQueryParameter['includePrivate'] = includePrivate;
            }

            if (includePending !== undefined) {
                localVarQueryParameter['includePending'] = includePending;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/timeoff/whosout',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of policy names for the user\'s defined policy type.<br />
         * @summary Get a list of policy names for a given policy type.
         * @param {string} policyTypeName Policy type name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPolicyTypeNames: async (policyTypeName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyTypeName' is not null or undefined
            assertParamExists('listPolicyTypeNames', 'policyTypeName', policyTypeName)
            const localVarPath = `/timeoff/policies/names`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)
            if (policyTypeName !== undefined) {
                localVarQueryParameter['policyTypeName'] = policyTypeName;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/timeoff/policies/names',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all policy type names.<br />
         * @summary Get all policy types names.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPolicyTypesNames: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/timeoff/policy-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/timeoff/policy-types',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of reason codes for a given policy type.<br />
         * @summary Get Policy type reason codes
         * @param {string} policyType Policy Type name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listReasonCodes: async (policyType: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyType' is not null or undefined
            assertParamExists('listReasonCodes', 'policyType', policyType)
            const localVarPath = `/timeoff/policy-types/{policyType}/reason-codes`
                .replace(`{${"policyType"}}`, encodeURIComponent(String(policyType !== undefined ? policyType : `-policyType-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/timeoff/policy-types/{policyType}/reason-codes',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submits a new timeoff request.<br />
         * @summary Submit a new time off request.
         * @param {string} id Employee ID.
         * @param {SubmitTimeoffRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitNewRequest: async (id: string, body: SubmitTimeoffRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('submitNewRequest', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('submitNewRequest', 'body', body)
            const localVarPath = `/timeoff/employees/{id}/requests`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: body,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/timeoff/employees/{id}/requests',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submits a new timeoff request of different hours per day.<br /><b>Supported user types:</b> Employee, Service.
         * @summary Submit a new time off request of different hours per day.
         * @param {string} id Employee ID.
         * @param {SubmitTimeoffRequestDiffHours} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitNewRequestDiffHours: async (id: string, body: SubmitTimeoffRequestDiffHours, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('submitNewRequestDiffHours', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('submitNewRequestDiffHours', 'body', body)
            const localVarPath = `/timeoff/employees/{id}/diffHours/requests`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)
            // authentication Bearer required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "bearer", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: body,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/timeoff/employees/{id}/diffHours/requests',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TimeOffApi - functional programming interface
 * @export
 */
export const TimeOffApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TimeOffApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a list of reason codes for a given policy type.<br /><b>Supported user types:</b> Service.
         * @summary Add a list of reason codes for a given policy type.
         * @param {TimeOffApiAddReasonCodesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addReasonCodes(requestParameters: TimeOffApiAddReasonCodesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const body: ReasonCodesNames = {
                reasonCodes: requestParameters.reasonCodes
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.addReasonCodes(requestParameters.policyType, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cancels an existing time off request.<br />
         * @summary Cancel an existing timeoff request
         * @param {TimeOffApiCancelRequestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelRequest(requestParameters: TimeOffApiCancelRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelRequest(requestParameters.id, requestParameters.requestId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a balance adjustment for a given employee for a given effective date.<br />
         * @summary Create a balance adjustment.
         * @param {TimeOffApiCreateBalanceAdjustmentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBalanceAdjustment(requestParameters: TimeOffApiCreateBalanceAdjustmentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const body: AdjustmentRequest = {
                adjustmentType: requestParameters.adjustmentType,
                policyType: requestParameters.policyType,
                effectiveDate: requestParameters.effectiveDate,
                amount: requestParameters.amount,
                reason: requestParameters.reason
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBalanceAdjustment(requestParameters.id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Supplies detailed info about an existing time off request.<br />
         * @summary Get the details of an existing timeoff request.
         * @param {TimeOffApiGetDetailsOfRequestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDetailsOfRequest(requestParameters: TimeOffApiGetDetailsOfRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimeoffRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDetailsOfRequest(requestParameters.id, requestParameters.requestId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve the balance for a given employee, for a given policy type, as of a given date.<br />
         * @summary Get the balance for a given employee
         * @param {TimeOffApiGetEmployeeBalanceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEmployeeBalance(requestParameters: TimeOffApiGetEmployeeBalanceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BalanceResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEmployeeBalance(requestParameters.id, requestParameters.policyType, requestParameters.date, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the list of time off requests that are pending, approved or canceled since the specified date.<br />
         * @summary Get all new/deleted time off requests since the specified date.
         * @param {TimeOffApiGetNewDeletedRequestsSinceDateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNewDeletedRequestsSinceDate(requestParameters: TimeOffApiGetNewDeletedRequestsSinceDateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimeoffChanges>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNewDeletedRequestsSinceDate(requestParameters.since, requestParameters.includePending, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the list of people that have a time off request today or on the specified date.<br />
         * @summary Read a list of who\'s out of the office today or on the specified date.
         * @param {TimeOffApiGetOutOfOfficeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOutOfOffice(requestParameters: TimeOffApiGetOutOfOfficeRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OutTodays>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOutOfOffice(requestParameters.today, requestParameters.includeHourly, requestParameters.includePrivate, requestParameters.siteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get details about a given policy type.<br />
         * @summary Get Policy type details
         * @param {TimeOffApiGetPolicyDetailsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolicyDetails(requestParameters: TimeOffApiGetPolicyDetailsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolicyDetails(requestParameters.policyType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get details about a given policy.<br />
         * @summary Get Policy details.
         * @param {TimeOffApiGetPolicyDetails0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolicyDetails_1(requestParameters: TimeOffApiGetPolicyDetails0Request, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Policy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolicyDetails_1(requestParameters.policyName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns time off information for a given date range.<br /><b>Supported user types:</b> Service.
         * @summary Read a list of who\'s out of the office.
         * @param {TimeOffApiGetWhosOutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWhosOut(requestParameters: TimeOffApiGetWhosOutRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Requests>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWhosOut(requestParameters.from, requestParameters.to, requestParameters.includeHourly, requestParameters.includePrivate, requestParameters.includePending, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of policy names for the user\'s defined policy type.<br />
         * @summary Get a list of policy names for a given policy type.
         * @param {TimeOffApiListPolicyTypeNamesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPolicyTypeNames(requestParameters: TimeOffApiListPolicyTypeNamesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyNames>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPolicyTypeNames(requestParameters.policyTypeName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of all policy type names.<br />
         * @summary Get all policy types names.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPolicyTypesNames(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyTypes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPolicyTypesNames(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get list of reason codes for a given policy type.<br />
         * @summary Get Policy type reason codes
         * @param {TimeOffApiListReasonCodesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listReasonCodes(requestParameters: TimeOffApiListReasonCodesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReasonCodes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listReasonCodes(requestParameters.policyType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Submits a new timeoff request.<br />
         * @summary Submit a new time off request.
         * @param {TimeOffApiSubmitNewRequestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitNewRequest(requestParameters: TimeOffApiSubmitNewRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const body: SubmitTimeoffRequest = {
                description: requestParameters.description,
                policyType: requestParameters.policyType,
                requestRangeType: requestParameters.requestRangeType,
                startDate: requestParameters.startDate,
                startDatePortion: requestParameters.startDatePortion,
                endDate: requestParameters.endDate,
                hours: requestParameters.hours,
                minutes: requestParameters.minutes,
                endDatePortion: requestParameters.endDatePortion,
                dayPortion: requestParameters.dayPortion,
                dailyHours: requestParameters.dailyHours,
                dailyMinutes: requestParameters.dailyMinutes,
                skipManagerApproval: requestParameters.skipManagerApproval,
                approver: requestParameters.approver,
                reasonCode: requestParameters.reasonCode
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitNewRequest(requestParameters.id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Submits a new timeoff request of different hours per day.<br /><b>Supported user types:</b> Employee, Service.
         * @summary Submit a new time off request of different hours per day.
         * @param {TimeOffApiSubmitNewRequestDiffHoursRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitNewRequestDiffHours(requestParameters: TimeOffApiSubmitNewRequestDiffHoursRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const body: SubmitTimeoffRequestDiffHours = {
                description: requestParameters.description,
                policyType: requestParameters.policyType,
                startDate: requestParameters.startDate,
                endDate: requestParameters.endDate,
                durations: requestParameters.durations,
                skipManagerApproval: requestParameters.skipManagerApproval,
                approver: requestParameters.approver,
                reasonCode: requestParameters.reasonCode
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitNewRequestDiffHours(requestParameters.id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TimeOffApi - factory interface
 * @export
 */
export const TimeOffApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TimeOffApiFp(configuration)
    return {
        /**
         * Add a list of reason codes for a given policy type.<br /><b>Supported user types:</b> Service.
         * @summary Add a list of reason codes for a given policy type.
         * @param {TimeOffApiAddReasonCodesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addReasonCodes(requestParameters: TimeOffApiAddReasonCodesRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addReasonCodes(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancels an existing time off request.<br />
         * @summary Cancel an existing timeoff request
         * @param {TimeOffApiCancelRequestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelRequest(requestParameters: TimeOffApiCancelRequestRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.cancelRequest(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a balance adjustment for a given employee for a given effective date.<br />
         * @summary Create a balance adjustment.
         * @param {TimeOffApiCreateBalanceAdjustmentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBalanceAdjustment(requestParameters: TimeOffApiCreateBalanceAdjustmentRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createBalanceAdjustment(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Supplies detailed info about an existing time off request.<br />
         * @summary Get the details of an existing timeoff request.
         * @param {TimeOffApiGetDetailsOfRequestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDetailsOfRequest(requestParameters: TimeOffApiGetDetailsOfRequestRequest, options?: AxiosRequestConfig): AxiosPromise<TimeoffRequest> {
            return localVarFp.getDetailsOfRequest(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the balance for a given employee, for a given policy type, as of a given date.<br />
         * @summary Get the balance for a given employee
         * @param {TimeOffApiGetEmployeeBalanceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmployeeBalance(requestParameters: TimeOffApiGetEmployeeBalanceRequest, options?: AxiosRequestConfig): AxiosPromise<BalanceResult> {
            return localVarFp.getEmployeeBalance(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of time off requests that are pending, approved or canceled since the specified date.<br />
         * @summary Get all new/deleted time off requests since the specified date.
         * @param {TimeOffApiGetNewDeletedRequestsSinceDateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewDeletedRequestsSinceDate(requestParameters: TimeOffApiGetNewDeletedRequestsSinceDateRequest, options?: AxiosRequestConfig): AxiosPromise<TimeoffChanges> {
            return localVarFp.getNewDeletedRequestsSinceDate(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of people that have a time off request today or on the specified date.<br />
         * @summary Read a list of who\'s out of the office today or on the specified date.
         * @param {TimeOffApiGetOutOfOfficeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOutOfOffice(requestParameters: TimeOffApiGetOutOfOfficeRequest = {}, options?: AxiosRequestConfig): AxiosPromise<OutTodays> {
            return localVarFp.getOutOfOffice(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details about a given policy type.<br />
         * @summary Get Policy type details
         * @param {TimeOffApiGetPolicyDetailsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicyDetails(requestParameters: TimeOffApiGetPolicyDetailsRequest, options?: AxiosRequestConfig): AxiosPromise<PolicyType> {
            return localVarFp.getPolicyDetails(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details about a given policy.<br />
         * @summary Get Policy details.
         * @param {TimeOffApiGetPolicyDetails0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicyDetails_1(requestParameters: TimeOffApiGetPolicyDetails0Request, options?: AxiosRequestConfig): AxiosPromise<Policy> {
            return localVarFp.getPolicyDetails_1(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns time off information for a given date range.<br /><b>Supported user types:</b> Service.
         * @summary Read a list of who\'s out of the office.
         * @param {TimeOffApiGetWhosOutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWhosOut(requestParameters: TimeOffApiGetWhosOutRequest, options?: AxiosRequestConfig): AxiosPromise<Requests> {
            return localVarFp.getWhosOut(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of policy names for the user\'s defined policy type.<br />
         * @summary Get a list of policy names for a given policy type.
         * @param {TimeOffApiListPolicyTypeNamesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPolicyTypeNames(requestParameters: TimeOffApiListPolicyTypeNamesRequest, options?: AxiosRequestConfig): AxiosPromise<PolicyNames> {
            return localVarFp.listPolicyTypeNames(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all policy type names.<br />
         * @summary Get all policy types names.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPolicyTypesNames(options?: AxiosRequestConfig): AxiosPromise<PolicyTypes> {
            return localVarFp.listPolicyTypesNames(options).then((request) => request(axios, basePath));
        },
        /**
         * Get list of reason codes for a given policy type.<br />
         * @summary Get Policy type reason codes
         * @param {TimeOffApiListReasonCodesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listReasonCodes(requestParameters: TimeOffApiListReasonCodesRequest, options?: AxiosRequestConfig): AxiosPromise<ReasonCodes> {
            return localVarFp.listReasonCodes(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Submits a new timeoff request.<br />
         * @summary Submit a new time off request.
         * @param {TimeOffApiSubmitNewRequestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitNewRequest(requestParameters: TimeOffApiSubmitNewRequestRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.submitNewRequest(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Submits a new timeoff request of different hours per day.<br /><b>Supported user types:</b> Employee, Service.
         * @summary Submit a new time off request of different hours per day.
         * @param {TimeOffApiSubmitNewRequestDiffHoursRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitNewRequestDiffHours(requestParameters: TimeOffApiSubmitNewRequestDiffHoursRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.submitNewRequestDiffHours(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addReasonCodes operation in TimeOffApi.
 * @export
 * @interface TimeOffApiAddReasonCodesRequest
 */
export type TimeOffApiAddReasonCodesRequest = {
    
    /**
    * Policy Type name
    * @type {string}
    * @memberof TimeOffApiAddReasonCodes
    */
    readonly policyType: string
    
} & ReasonCodesNames

/**
 * Request parameters for cancelRequest operation in TimeOffApi.
 * @export
 * @interface TimeOffApiCancelRequestRequest
 */
export type TimeOffApiCancelRequestRequest = {
    
    /**
    * Employee ID.
    * @type {string}
    * @memberof TimeOffApiCancelRequest
    */
    readonly id: string
    
    /**
    * Request ID.
    * @type {number}
    * @memberof TimeOffApiCancelRequest
    */
    readonly requestId: number
    
}

/**
 * Request parameters for createBalanceAdjustment operation in TimeOffApi.
 * @export
 * @interface TimeOffApiCreateBalanceAdjustmentRequest
 */
export type TimeOffApiCreateBalanceAdjustmentRequest = {
    
    /**
    * Employee ID.
    * @type {string}
    * @memberof TimeOffApiCreateBalanceAdjustment
    */
    readonly id: string
    
} & AdjustmentRequest

/**
 * Request parameters for getDetailsOfRequest operation in TimeOffApi.
 * @export
 * @interface TimeOffApiGetDetailsOfRequestRequest
 */
export type TimeOffApiGetDetailsOfRequestRequest = {
    
    /**
    * employee id
    * @type {string}
    * @memberof TimeOffApiGetDetailsOfRequest
    */
    readonly id: string
    
    /**
    * request id
    * @type {number}
    * @memberof TimeOffApiGetDetailsOfRequest
    */
    readonly requestId: number
    
}

/**
 * Request parameters for getEmployeeBalance operation in TimeOffApi.
 * @export
 * @interface TimeOffApiGetEmployeeBalanceRequest
 */
export type TimeOffApiGetEmployeeBalanceRequest = {
    
    /**
    * Employee ID.
    * @type {string}
    * @memberof TimeOffApiGetEmployeeBalance
    */
    readonly id: string
    
    /**
    * Policy type name.
    * @type {string}
    * @memberof TimeOffApiGetEmployeeBalance
    */
    readonly policyType: string
    
    /**
    * Point in time.
    * @type {string | Date}
    * @memberof TimeOffApiGetEmployeeBalance
    */
    readonly date: string | Date
    
}

/**
 * Request parameters for getNewDeletedRequestsSinceDate operation in TimeOffApi.
 * @export
 * @interface TimeOffApiGetNewDeletedRequestsSinceDateRequest
 */
export type TimeOffApiGetNewDeletedRequestsSinceDateRequest = {
    
    /**
    * Timestamp starting from which to return the changes. Should be in ISO-8601 format, e.g. 2050-04-05T14:30:24.345Z or 2050-04-05T12:30-02:00.
    * @type {string | Date}
    * @memberof TimeOffApiGetNewDeletedRequestsSinceDate
    */
    readonly since: string | Date
    
    /**
    * Optional parameter. Indicates whether to include pending requests in the results.
    * @type {boolean}
    * @memberof TimeOffApiGetNewDeletedRequestsSinceDate
    */
    readonly includePending?: boolean
    
}

/**
 * Request parameters for getOutOfOffice operation in TimeOffApi.
 * @export
 * @interface TimeOffApiGetOutOfOfficeRequest
 */
export type TimeOffApiGetOutOfOfficeRequest = {
    
    /**
    * Date to report out of the office. If not specified, the date at UTC at the time of the request is used.
    * @type {string | Date}
    * @memberof TimeOffApiGetOutOfOffice
    */
    readonly today?: string | Date
    
    /**
    * Include Hourly Requests
    * @type {boolean}
    * @memberof TimeOffApiGetOutOfOffice
    */
    readonly includeHourly?: boolean
    
    /**
    * Show the policy type\'s name instead of the policy\'s custom public name if the user has permission to view it, and the policy\'s custom public name exists.
    * @type {boolean}
    * @memberof TimeOffApiGetOutOfOffice
    */
    readonly includePrivate?: boolean
    
    /**
    * The employee\'s site ID
    * @type {number}
    * @memberof TimeOffApiGetOutOfOffice
    */
    readonly siteId?: number
    
}

/**
 * Request parameters for getPolicyDetails operation in TimeOffApi.
 * @export
 * @interface TimeOffApiGetPolicyDetailsRequest
 */
export type TimeOffApiGetPolicyDetailsRequest = {
    
    /**
    * Policy Type name
    * @type {string}
    * @memberof TimeOffApiGetPolicyDetails
    */
    readonly policyType: string
    
}

/**
 * Request parameters for getPolicyDetails_1 operation in TimeOffApi.
 * @export
 * @interface TimeOffApiGetPolicyDetails0Request
 */
export type TimeOffApiGetPolicyDetails0Request = {
    
    /**
    * Policy name.
    * @type {string}
    * @memberof TimeOffApiGetPolicyDetails0
    */
    readonly policyName: string
    
}

/**
 * Request parameters for getWhosOut operation in TimeOffApi.
 * @export
 * @interface TimeOffApiGetWhosOutRequest
 */
export type TimeOffApiGetWhosOutRequest = {
    
    /**
    * Start period date
    * @type {string | Date}
    * @memberof TimeOffApiGetWhosOut
    */
    readonly from: string | Date
    
    /**
    * End period date
    * @type {string | Date}
    * @memberof TimeOffApiGetWhosOut
    */
    readonly to: string | Date
    
    /**
    * Include Hourly Requests
    * @type {boolean}
    * @memberof TimeOffApiGetWhosOut
    */
    readonly includeHourly?: boolean
    
    /**
    * Show the policy type\'s name instead of the policy\'s custom public name if the user has permission to view it, and the policy\'s custom public name exists.
    * @type {boolean}
    * @memberof TimeOffApiGetWhosOut
    */
    readonly includePrivate?: boolean
    
    /**
    * Include Pending Requests
    * @type {boolean}
    * @memberof TimeOffApiGetWhosOut
    */
    readonly includePending?: boolean
    
}

/**
 * Request parameters for listPolicyTypeNames operation in TimeOffApi.
 * @export
 * @interface TimeOffApiListPolicyTypeNamesRequest
 */
export type TimeOffApiListPolicyTypeNamesRequest = {
    
    /**
    * Policy type name.
    * @type {string}
    * @memberof TimeOffApiListPolicyTypeNames
    */
    readonly policyTypeName: string
    
}

/**
 * Request parameters for listReasonCodes operation in TimeOffApi.
 * @export
 * @interface TimeOffApiListReasonCodesRequest
 */
export type TimeOffApiListReasonCodesRequest = {
    
    /**
    * Policy Type name.
    * @type {string}
    * @memberof TimeOffApiListReasonCodes
    */
    readonly policyType: string
    
}

/**
 * Request parameters for submitNewRequest operation in TimeOffApi.
 * @export
 * @interface TimeOffApiSubmitNewRequestRequest
 */
export type TimeOffApiSubmitNewRequestRequest = {
    
    /**
    * Employee ID.
    * @type {string}
    * @memberof TimeOffApiSubmitNewRequest
    */
    readonly id: string
    
} & SubmitTimeoffRequest

/**
 * Request parameters for submitNewRequestDiffHours operation in TimeOffApi.
 * @export
 * @interface TimeOffApiSubmitNewRequestDiffHoursRequest
 */
export type TimeOffApiSubmitNewRequestDiffHoursRequest = {
    
    /**
    * Employee ID.
    * @type {string}
    * @memberof TimeOffApiSubmitNewRequestDiffHours
    */
    readonly id: string
    
} & SubmitTimeoffRequestDiffHours

/**
 * TimeOffApiGenerated - object-oriented interface
 * @export
 * @class TimeOffApiGenerated
 * @extends {BaseAPI}
 */
export class TimeOffApiGenerated extends BaseAPI {
    /**
     * Add a list of reason codes for a given policy type.<br /><b>Supported user types:</b> Service.
     * @summary Add a list of reason codes for a given policy type.
     * @param {TimeOffApiAddReasonCodesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeOffApiGenerated
     */
    public addReasonCodes(requestParameters: TimeOffApiAddReasonCodesRequest, options?: AxiosRequestConfig) {
        return TimeOffApiFp(this.configuration).addReasonCodes(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancels an existing time off request.<br />
     * @summary Cancel an existing timeoff request
     * @param {TimeOffApiCancelRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeOffApiGenerated
     */
    public cancelRequest(requestParameters: TimeOffApiCancelRequestRequest, options?: AxiosRequestConfig) {
        return TimeOffApiFp(this.configuration).cancelRequest(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a balance adjustment for a given employee for a given effective date.<br />
     * @summary Create a balance adjustment.
     * @param {TimeOffApiCreateBalanceAdjustmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeOffApiGenerated
     */
    public createBalanceAdjustment(requestParameters: TimeOffApiCreateBalanceAdjustmentRequest, options?: AxiosRequestConfig) {
        return TimeOffApiFp(this.configuration).createBalanceAdjustment(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Supplies detailed info about an existing time off request.<br />
     * @summary Get the details of an existing timeoff request.
     * @param {TimeOffApiGetDetailsOfRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeOffApiGenerated
     */
    public getDetailsOfRequest(requestParameters: TimeOffApiGetDetailsOfRequestRequest, options?: AxiosRequestConfig) {
        return TimeOffApiFp(this.configuration).getDetailsOfRequest(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the balance for a given employee, for a given policy type, as of a given date.<br />
     * @summary Get the balance for a given employee
     * @param {TimeOffApiGetEmployeeBalanceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeOffApiGenerated
     */
    public getEmployeeBalance(requestParameters: TimeOffApiGetEmployeeBalanceRequest, options?: AxiosRequestConfig) {
        return TimeOffApiFp(this.configuration).getEmployeeBalance(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of time off requests that are pending, approved or canceled since the specified date.<br />
     * @summary Get all new/deleted time off requests since the specified date.
     * @param {TimeOffApiGetNewDeletedRequestsSinceDateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeOffApiGenerated
     */
    public getNewDeletedRequestsSinceDate(requestParameters: TimeOffApiGetNewDeletedRequestsSinceDateRequest, options?: AxiosRequestConfig) {
        return TimeOffApiFp(this.configuration).getNewDeletedRequestsSinceDate(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of people that have a time off request today or on the specified date.<br />
     * @summary Read a list of who\'s out of the office today or on the specified date.
     * @param {TimeOffApiGetOutOfOfficeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeOffApiGenerated
     */
    public getOutOfOffice(requestParameters: TimeOffApiGetOutOfOfficeRequest = {}, options?: AxiosRequestConfig) {
        return TimeOffApiFp(this.configuration).getOutOfOffice(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details about a given policy type.<br />
     * @summary Get Policy type details
     * @param {TimeOffApiGetPolicyDetailsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeOffApiGenerated
     */
    public getPolicyDetails(requestParameters: TimeOffApiGetPolicyDetailsRequest, options?: AxiosRequestConfig) {
        return TimeOffApiFp(this.configuration).getPolicyDetails(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details about a given policy.<br />
     * @summary Get Policy details.
     * @param {TimeOffApiGetPolicyDetails0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeOffApiGenerated
     */
    public getPolicyDetails_1(requestParameters: TimeOffApiGetPolicyDetails0Request, options?: AxiosRequestConfig) {
        return TimeOffApiFp(this.configuration).getPolicyDetails_1(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns time off information for a given date range.<br /><b>Supported user types:</b> Service.
     * @summary Read a list of who\'s out of the office.
     * @param {TimeOffApiGetWhosOutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeOffApiGenerated
     */
    public getWhosOut(requestParameters: TimeOffApiGetWhosOutRequest, options?: AxiosRequestConfig) {
        return TimeOffApiFp(this.configuration).getWhosOut(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of policy names for the user\'s defined policy type.<br />
     * @summary Get a list of policy names for a given policy type.
     * @param {TimeOffApiListPolicyTypeNamesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeOffApiGenerated
     */
    public listPolicyTypeNames(requestParameters: TimeOffApiListPolicyTypeNamesRequest, options?: AxiosRequestConfig) {
        return TimeOffApiFp(this.configuration).listPolicyTypeNames(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all policy type names.<br />
     * @summary Get all policy types names.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeOffApiGenerated
     */
    public listPolicyTypesNames(options?: AxiosRequestConfig) {
        return TimeOffApiFp(this.configuration).listPolicyTypesNames(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list of reason codes for a given policy type.<br />
     * @summary Get Policy type reason codes
     * @param {TimeOffApiListReasonCodesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeOffApiGenerated
     */
    public listReasonCodes(requestParameters: TimeOffApiListReasonCodesRequest, options?: AxiosRequestConfig) {
        return TimeOffApiFp(this.configuration).listReasonCodes(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submits a new timeoff request.<br />
     * @summary Submit a new time off request.
     * @param {TimeOffApiSubmitNewRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeOffApiGenerated
     */
    public submitNewRequest(requestParameters: TimeOffApiSubmitNewRequestRequest, options?: AxiosRequestConfig) {
        return TimeOffApiFp(this.configuration).submitNewRequest(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submits a new timeoff request of different hours per day.<br /><b>Supported user types:</b> Employee, Service.
     * @summary Submit a new time off request of different hours per day.
     * @param {TimeOffApiSubmitNewRequestDiffHoursRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeOffApiGenerated
     */
    public submitNewRequestDiffHours(requestParameters: TimeOffApiSubmitNewRequestDiffHoursRequest, options?: AxiosRequestConfig) {
        return TimeOffApiFp(this.configuration).submitNewRequestDiffHours(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
